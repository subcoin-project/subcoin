//! # Bitcoin Pallet
//!
//! This pallet is designed to be minimalist, containing only one storage item for maintaining
//! the state of the UTXO (Unspent Transaction Output) set by processing the inputs and outputs
//! of each Bitcoin transaction wrapped in [`Call::transact`]. There is no verification logic
//! within the pallet, all validation work should be performed outside the runtime. This approach
//! simplifies off-runtime execution, allowing for easier syncing performance optimization off
//! chain.

// Ensure we're `no_std` when compiling for Wasm.
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(test)]
mod mock;
#[cfg(test)]
mod tests;
pub mod types;

use self::types::{OutPoint, Transaction, Txid};
use bitcoin::consensus::Decodable;
use frame_support::dispatch::DispatchResult;
use frame_support::weights::Weight;
use sp_runtime::traits::BlockNumberProvider;
use sp_runtime::SaturatedConversion;
use sp_std::prelude::*;
use sp_std::vec::Vec;
use subcoin_runtime_primitives::Coin;

// Re-export pallet items so that they can be accessed from the crate namespace.
pub use pallet::*;

/// Transaction output index.
pub type OutputIndex = u32;

/// Weight functions needed for `pallet_bitcoin`.
pub trait WeightInfo {
    /// Calculates the weight of [`Call::transact`].
    fn transact(btc_tx: &Transaction) -> Weight;
}

impl WeightInfo for () {
    fn transact(_: &Transaction) -> Weight {
        Weight::zero()
    }
}

/// A struct that implements the [`WeightInfo`] trait for Bitcoin transactions.
pub struct BitcoinTransactionWeight;

impl WeightInfo for BitcoinTransactionWeight {
    fn transact(btc_tx: &Transaction) -> Weight {
        let btc_weight = bitcoin::Transaction::from(btc_tx.clone()).weight().to_wu();
        Weight::from_parts(btc_weight, 0u64)
    }
}

#[frame_support::pallet]
pub mod pallet {
    use super::*;
    use frame_support::pallet_prelude::*;
    use frame_system::pallet_prelude::*;

    #[pallet::config]
    pub trait Config: frame_system::Config {
        /// The overarching event type.
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

        type WeightInfo: WeightInfo;
    }

    #[pallet::pallet]
    pub struct Pallet<T>(_);

    #[pallet::call(weight(<T as Config>::WeightInfo))]
    impl<T: Config> Pallet<T> {
        /// An unsigned extrinsic for embedding a Bitcoin transaction into the Substrate block.
        #[pallet::call_index(0)]
        #[pallet::weight((T::WeightInfo::transact(btc_tx), DispatchClass::Normal, Pays::No))]
        pub fn transact(origin: OriginFor<T>, btc_tx: Transaction) -> DispatchResult {
            ensure_none(origin)?;

            Self::process_bitcoin_transaction(btc_tx.into());

            Ok(())
        }
    }

    #[pallet::genesis_config]
    pub struct GenesisConfig<T> {
        pub genesis_tx: Vec<u8>,
        pub _config: core::marker::PhantomData<T>,
    }

    // Custom Default impl to make `test_genesis_config_builds()` in runtime happy.
    impl<T: Config> Default for GenesisConfig<T> {
        fn default() -> Self {
            // `genesis_tx` is generated by
            // `subcoin_primitives::bitcoin_genesis_tx(bitcoin::Network::Bitcoin)`.
            let genesis_tx = [
                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 77, 4, 255, 255, 0, 29, 1, 4, 69,
                84, 104, 101, 32, 84, 105, 109, 101, 115, 32, 48, 51, 47, 74, 97, 110, 47, 50, 48,
                48, 57, 32, 67, 104, 97, 110, 99, 101, 108, 108, 111, 114, 32, 111, 110, 32, 98,
                114, 105, 110, 107, 32, 111, 102, 32, 115, 101, 99, 111, 110, 100, 32, 98, 97, 105,
                108, 111, 117, 116, 32, 102, 111, 114, 32, 98, 97, 110, 107, 115, 255, 255, 255,
                255, 1, 0, 242, 5, 42, 1, 0, 0, 0, 67, 65, 4, 103, 138, 253, 176, 254, 85, 72, 39,
                25, 103, 241, 166, 113, 48, 183, 16, 92, 214, 168, 40, 224, 57, 9, 166, 121, 98,
                224, 234, 31, 97, 222, 182, 73, 246, 188, 63, 76, 239, 56, 196, 243, 85, 4, 229,
                30, 193, 18, 222, 92, 56, 77, 247, 186, 11, 141, 87, 138, 76, 112, 43, 107, 241,
                29, 95, 172, 0, 0, 0, 0,
            ];

            Self {
                genesis_tx: genesis_tx.to_vec(),
                _config: Default::default(),
            }
        }
    }

    #[pallet::genesis_build]
    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
        fn build(&self) {
            let genesis_tx =
                bitcoin::Transaction::consensus_decode(&mut self.genesis_tx.clone().as_slice())
                    .unwrap_or_else(|_| {
                        panic!(
                            "Transaction constructed internally must be decoded successfully; qed"
                        )
                    });

            let txid = Txid::from_bitcoin_txid(genesis_tx.compute_txid());

            genesis_tx
                .output
                .iter()
                .enumerate()
                .for_each(|(index, txout)| {
                    let coin = Coin {
                        is_coinbase: true,
                        amount: txout.value.to_sat(),
                        script_pubkey: txout.script_pubkey.clone().into_bytes(),
                        height: 0u32,
                    };
                    Coins::<T>::insert(txid, index as u32, coin);
                });
        }
    }

    #[pallet::event]
    pub enum Event<T: Config> {}

    /// UTXO set.
    ///
    /// (Txid, OutputIndex(vout), Coin)
    #[pallet::storage]
    pub type Coins<T> =
        StorageDoubleMap<_, Identity, Txid, Identity, OutputIndex, Coin, OptionQuery>;
}

/// Returns the storage key for the referenced output.
pub fn coin_storage_key<T: Config>(bitcoin_txid: bitcoin::Txid, vout: OutputIndex) -> Vec<u8> {
    use frame_support::storage::generator::StorageDoubleMap;

    let txid = Txid::from_bitcoin_txid(bitcoin_txid);
    Coins::<T>::storage_double_map_final_key(txid, vout)
}

/// Returns the final storage prefix for the storage item `Coins`.
pub fn coin_storage_prefix<T: Config>() -> [u8; 32] {
    use frame_support::StoragePrefixedMap;

    Coins::<T>::final_prefix()
}

impl<T: Config> Pallet<T> {
    fn process_bitcoin_transaction(tx: bitcoin::Transaction) {
        let txid = tx.compute_txid();
        let is_coinbase = tx.is_coinbase();

        let height = frame_system::Pallet::<T>::current_block_number();

        let new_coins = tx.output.into_iter().enumerate().map(|(index, txout)| {
            let out_point = bitcoin::OutPoint {
                txid,
                vout: index as u32,
            };
            let coin = Coin {
                is_coinbase,
                amount: txout.value.to_sat(),
                script_pubkey: txout.script_pubkey.into_bytes(),
                height: height.saturated_into(),
            };
            (out_point, coin)
        });

        let num_created = new_coins.len();

        if is_coinbase {
            for (out_point, coin) in new_coins {
                let OutPoint { txid, output_index } = OutPoint::from(out_point);
                Coins::<T>::insert(txid, output_index, coin);
            }
            CoinsCount::<T>::mutate(|v| {
                *v = *v + num_created as u64;
            });
            return;
        }

        // Process inputs.
        for input in tx.input {
            let previous_output = input.previous_output;
            let OutPoint { txid, output_index } = OutPoint::from(previous_output);
            if let Some(_spent) = Coins::<T>::take(txid, output_index) {
            } else {
                panic!("Corruputed state, UTXO {previous_output:?} not found");
            }
        }

        // Process outputs.
        for (out_point, coin) in new_coins {
            let OutPoint { txid, output_index } = OutPoint::from(out_point);
            Coins::<T>::insert(txid, output_index, coin);
        }
    }
}
